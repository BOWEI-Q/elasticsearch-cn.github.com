---
layout: guide
title: Query DSL
cat: 向导
cat_link: guide
sidebar: 帮助文档_query_dsl
---

p. *elasticsearch* 提供基于JSON的完整的Query DSL查询表达式. 一般来说, 普通的查询如 "项(term)":term-query.html 或者 "前缀(prefix)":prefix-query.html. 另外还有混合查询如 "布尔查询(bool)":bool-query.html 等. 另外查询表达式(Queries)还能够关联特定的过滤表达式，如 "filtered":filtered-query.html 或者 "constant_score":constant-score-query.html 查询. 

p. 你可以把Query DSL当作是一系列的抽象的查询表达式树（ "AST":http://en.wikipedia.org/wiki/Abstract_syntax_tree ）. 特定查询能够包含其它的查询，(如 "布尔查询（bool）":bool-query.html ), 有些查询能够包含过滤器other can contain filters (如 "constant_score":constant-score-query.html), 还有的可以同时包含查询和过滤器 (如 "filtered":filtered-query.html). 能够都能够从ES支持查询集合里面包含任意一个查询或者是过滤器集合里面的任意一个过滤器, 这样的话，我们就可以构造出任意复杂（maybe 非常有趣）的查询了.

p. 查询和过滤都可以被用于各种不同的API接口里面. 举例说明, 在 "search query":/guide/reference/api/search/query.html, 或者是 "facet filter":/guide/reference/api/search/facets/ 里面等等. 这部分解释构造AST能够用到的各种查询或者过滤器.

p 提示. 过滤器非常有用因为他们比简单的查询更快（不进行文档评分）并且会自动缓存.

h1. 过滤器和缓存（Filters and Caching）

p. 过滤器是用来缓存的不错的方式. 缓存这些过滤结果并不需要太多的内存, 而且其它的查询可以重用这些过滤（同样参数哦），所以速度是刷刷的.

p. 某些过滤产生的结果是很易于缓存的，有关缓存与否的区别在于是否存放过滤结果到缓存中，像如下过滤器如 "term":term-filter.html, "terms":terms-filter.html, "prefix":prefix-filter.html, 和 "range":range-filter.html 默认就是会进行缓存的, 并且建议使用这些过滤条件而不使用同等效果的查询.

p. 其它过滤器，通常通过将字段数据加载到内存中来来工作, 默认是不缓存结果的. 这些过滤操作的速度其实已经非常快了，如果将它们的结果缓存需要做额外的操作来使它们能够被其它查询使用，这些查询，包括地理位置的（geo）, "numeric_range":numeric-range-filter.html, 和 "script":script-filter.html 默认是没有缓存结果的.

p. 最后一个过滤器的类型是过滤器之间的组合， "and":and-filter.html, "not":not-filter.html 和 "or":or-filter.html ，这些过滤器是没有缓存结果的，因为它们主要是操作内联的过滤器，所以不需要过滤.

p. 所有的过滤器都允许设置 @_cache@ 元素来显式的控制缓存与否. 并且允许设置一个 @_cache_key@ 用来缓存的主键. 这个对于使用大集合过滤器的情况下非常有用 (如包含很多元素的 terms filter).
